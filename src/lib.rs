#[macro_use]
extern crate serde_derive;
extern crate bincode;
extern crate byteorder;
extern crate crypto;

use bincode::{serialize, deserialize};
use byteorder::{BigEndian, WriteBytesExt};
use crypto::aes::{self, KeySize};
use crypto::blockmodes::NoPadding;
use crypto::buffer::{BufferResult, RefReadBuffer, RefWriteBuffer, ReadBuffer, WriteBuffer};

#[derive(Serialize, Deserialize, PartialEq, Debug)]
pub struct EID {
    ranging_data: u8,
    eid: [u8; 8],
}

impl EID {
    pub fn new(key: &[u8], counter: u32, rot_period_exp: u8) -> EID {
        // See the following document for further details:
        //   https://github.com/google/eddystone/blob/master/eddystone-eid/eid-computation.md

        // "The K lowest bits are cleared."
        let counter = (counter >> rot_period_exp) << rot_period_exp;

        // Counter to bytes
        let mut ts = vec![];
        ts.write_u32::<BigEndian>(counter).unwrap();

        // "The temporary key is generated by AES-128 encrypting the
        //  following data structure with the identity key"
        let tk_data: [u8; 16] = [
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0xFF,
            0, 0,
            ts[0], ts[1],
        ];
        let tk = aes_encrypt(key, &tk_data);
        
        // "The 8-byte EID value is generated by AES-128 encrypting the
        //  following data structure with the temporary key"
        let eid_data: [u8; 16] = [
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            rot_period_exp,
            ts[0], ts[1], ts[2], ts[3],
        ];
        let eid = aes_encrypt(&tk, &eid_data);

        let mut truncated_eid: [u8; 8] = Default::default();
        truncated_eid.copy_from_slice(&eid[0..8]);
        EID { ranging_data: 0, eid: truncated_eid }
    }
    
    pub fn from_bytes(bytes: &[u8]) -> EID {
        let eid: EID = deserialize(bytes).unwrap();
        eid
    }

    pub fn to_bytes(&self) -> Vec<u8> {
        let bytes: Vec<u8> = serialize(self).unwrap();
        bytes
    }
}

fn aes_encrypt(key: &[u8], data: &[u8]) -> Vec<u8> {
    let mut encryptor = aes::ecb_encryptor(KeySize::KeySize128, key, NoPadding);
    let mut encrypted_data = Vec::<u8>::new();
    let mut buffer = [0; 256];
    let mut read_buffer = RefReadBuffer::new(&data);
    let mut write_buffer = RefWriteBuffer::new(&mut buffer);
    loop {
        let result = encryptor.encrypt(&mut read_buffer, &mut write_buffer, true).unwrap();
        encrypted_data.extend(write_buffer.take_read_buffer().take_remaining().iter().map(|&i| i));
        match result {
            BufferResult::BufferUnderflow => break,
            BufferResult::BufferOverflow => {} // TODO: return Error
        }   
    }
    encrypted_data
}

#[cfg(test)]
mod tests {
    extern crate hex;
    use super::*;

    struct EIDTest {
        ik: &'static str,
        counter: u32,
        rotation: u8,
        result: &'static str,
    }

    #[test]
    fn test_eid_computation() {
        let tests = [
            EIDTest {
                ik: "a2c873f26ebae374d9f7efbcd922ca1c", counter: 1258098495, rotation: 9,
                result: "ca8db2444f89ec78",
            },
            EIDTest {
                ik: "6e93678f9afa8214a4a4eadefa6743cd", counter: 2569247988, rotation: 13,
                result: "3deb9e6836f38314",
            },
            EIDTest {
                ik: "e2d10c4ec66c53750fba51597193de2f", counter: 65536, rotation: 9,
                result: "9d8ba7d1bd78b089",
            },
            EIDTest {
                ik: "ff13b262328beea97ac45aa14ac85c56", counter: 4294967295, rotation: 15,
                result: "a760539518d97522",
            },
            EIDTest {
                ik: "ef7593a5192c81eb79c0ee7c35d7440a", counter: 3721760299, rotation: 2,
                result: "eef8baae2fd4b815",
            },
            EIDTest {
                ik: "38a24ddc7ef73348035bef16d1931352", counter: 3897629132, rotation: 6,
                result: "ff3713dab2b86c72",
            },
            EIDTest {
                ik: "3c3f34117c7e49d984528d3ffa9adae3", counter: 1141546105, rotation: 9,
                result: "55d55138cdcebf08",
            },
        ];
        for test in tests.iter() {
            let ik = &hex::decode(test.ik).unwrap();
            let eid = EID::new(ik, test.counter, test.rotation);
            assert_eq!(eid.eid.to_vec(), hex::decode(test.result).unwrap());
        }
    }
}
